"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CartesianContext = void 0;
exports.CartesianContextProvider = CartesianContextProvider;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _d3Scale = require("d3-scale");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _extremums = require("../BarChart/extremums");
var _extremums2 = require("../ScatterChart/extremums");
var _extremums3 = require("../LineChart/extremums");
var _useScale = require("../hooks/useScale");
var _DrawingProvider = require("./DrawingProvider");
var _SeriesContextProvider = require("./SeriesContextProvider");
var _constants = require("../constants");
var _useTicks = require("../hooks/useTicks");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// TODO: those might be better placed in a distinct file
const xExtremumGetters = {
  bar: _extremums.getExtremumX,
  scatter: _extremums2.getExtremumX,
  line: _extremums3.getExtremumX
};
const yExtremumGetters = {
  bar: _extremums.getExtremumY,
  scatter: _extremums2.getExtremumY,
  line: _extremums3.getExtremumY
};
const CartesianContext = /*#__PURE__*/React.createContext({
  xAxis: {},
  yAxis: {},
  xAxisIds: [],
  yAxisIds: []
});
exports.CartesianContext = CartesianContext;
function CartesianContextProvider({
  xAxis,
  yAxis,
  children
}) {
  const formattedSeries = React.useContext(_SeriesContextProvider.SeriesContext);
  const drawingArea = React.useContext(_DrawingProvider.DrawingContext);
  const value = React.useMemo(() => {
    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {
      const getter = getters[chartType];
      const series = formattedSeries[chartType]?.series ?? {};
      const [minChartTypeData, maxChartTypeData] = getter({
        series,
        axis,
        isDefaultAxis
      });
      const [minData, maxData] = acc;
      if (minData === null || maxData === null) {
        return [minChartTypeData, maxChartTypeData];
      }
      if (minChartTypeData === null || maxChartTypeData === null) {
        return [minData, maxData];
      }
      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
    };
    const getAxisExtremum = (axis, getters, isDefaultAxis) => {
      const charTypes = Object.keys(getters);
      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);
    };
    const allXAxis = [...(xAxis?.map((axis, index) => (0, _extends2.default)({
      id: `deaultized-x-axis-${index}`
    }, axis)) ?? []),
    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY
    ...(xAxis === undefined || xAxis.findIndex(({
      id
    }) => id === _constants.DEFAULT_X_AXIS_KEY) === -1 ? [{
      id: _constants.DEFAULT_X_AXIS_KEY,
      scaleType: 'linear'
    }] : [])];
    const completedXAxis = {};
    allXAxis.forEach((axis, axisIndex) => {
      const isDefaultAxis = axisIndex === 0;
      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);
      const scaleType = axis.scaleType ?? 'linear';
      const range = [drawingArea.left, drawingArea.left + drawingArea.width];
      if (scaleType === 'band') {
        completedXAxis[axis.id] = (0, _extends2.default)({}, axis, {
          scaleType,
          scale: (0, _d3Scale.scaleBand)(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      if (scaleType === 'point') {
        completedXAxis[axis.id] = (0, _extends2.default)({}, axis, {
          scaleType,
          scale: (0, _d3Scale.scalePoint)(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      const extremums = [axis.min ?? minData, axis.max ?? maxData];
      const ticksNumber = (0, _useTicks.getTicksNumber)((0, _extends2.default)({}, axis, {
        range
      }));
      const niceScale = (0, _useScale.getScale)(scaleType, extremums, range).nice(ticksNumber);
      const niceDomain = niceScale.domain();
      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];
      completedXAxis[axis.id] = (0, _extends2.default)({}, axis, {
        scaleType,
        scale: niceScale.domain(domain),
        ticksNumber
      });
    });
    const allYAxis = [...(yAxis?.map((axis, index) => (0, _extends2.default)({
      id: `deaultized-y-axis-${index}`
    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({
      id
    }) => id === _constants.DEFAULT_Y_AXIS_KEY) === -1 ? [{
      id: _constants.DEFAULT_Y_AXIS_KEY,
      scaleType: 'linear'
    }] : [])];
    const completedYAxis = {};
    allYAxis.forEach((axis, axisIndex) => {
      const isDefaultAxis = axisIndex === 0;
      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);
      const range = [drawingArea.top + drawingArea.height, drawingArea.top];
      const scaleType = axis.scaleType ?? 'linear';
      if (scaleType === 'band') {
        completedYAxis[axis.id] = (0, _extends2.default)({}, axis, {
          scaleType,
          scale: (0, _d3Scale.scaleBand)(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      if (scaleType === 'point') {
        completedYAxis[axis.id] = (0, _extends2.default)({}, axis, {
          scaleType,
          scale: (0, _d3Scale.scalePoint)(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      const extremums = [axis.min ?? minData, axis.max ?? maxData];
      const ticksNumber = (0, _useTicks.getTicksNumber)((0, _extends2.default)({}, axis, {
        range
      }));
      const niceScale = (0, _useScale.getScale)(scaleType, extremums, range).nice(ticksNumber);
      const niceDomain = niceScale.domain();
      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];
      completedYAxis[axis.id] = (0, _extends2.default)({}, axis, {
        scaleType,
        scale: niceScale.domain(domain),
        ticksNumber
      });
    });
    return {
      xAxis: completedXAxis,
      yAxis: completedYAxis,
      xAxisIds: allXAxis.map(({
        id
      }) => id),
      yAxisIds: allYAxis.map(({
        id
      }) => id)
    };
  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);

  // @ts-ignore
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(CartesianContext.Provider, {
    value: value,
    children: children
  });
}
process.env.NODE_ENV !== "production" ? CartesianContextProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  children: _propTypes.default.node,
  xAxis: _propTypes.default.arrayOf(_propTypes.default.shape({
    axisId: _propTypes.default.string,
    classes: _propTypes.default.object,
    data: _propTypes.default.array,
    disableLine: _propTypes.default.bool,
    disableTicks: _propTypes.default.bool,
    fill: _propTypes.default.string,
    id: _propTypes.default.string,
    label: _propTypes.default.string,
    labelFontSize: _propTypes.default.number,
    max: _propTypes.default.number,
    maxTicks: _propTypes.default.number,
    min: _propTypes.default.number,
    minTicks: _propTypes.default.number,
    position: _propTypes.default.oneOf(['bottom', 'left', 'right', 'top']),
    scaleType: _propTypes.default.oneOf(['band', 'linear', 'log', 'point', 'pow', 'sqrt', 'time', 'utc']),
    stroke: _propTypes.default.string,
    tickFontSize: _propTypes.default.number,
    tickSize: _propTypes.default.number,
    tickSpacing: _propTypes.default.number,
    valueFormatter: _propTypes.default.func
  })),
  yAxis: _propTypes.default.arrayOf(_propTypes.default.shape({
    axisId: _propTypes.default.string,
    classes: _propTypes.default.object,
    data: _propTypes.default.array,
    disableLine: _propTypes.default.bool,
    disableTicks: _propTypes.default.bool,
    fill: _propTypes.default.string,
    id: _propTypes.default.string,
    label: _propTypes.default.string,
    labelFontSize: _propTypes.default.number,
    max: _propTypes.default.number,
    maxTicks: _propTypes.default.number,
    min: _propTypes.default.number,
    minTicks: _propTypes.default.number,
    position: _propTypes.default.oneOf(['bottom', 'left', 'right', 'top']),
    scaleType: _propTypes.default.oneOf(['band', 'linear', 'log', 'point', 'pow', 'sqrt', 'time', 'utc']),
    stroke: _propTypes.default.string,
    tickFontSize: _propTypes.default.number,
    tickSize: _propTypes.default.number,
    tickSpacing: _propTypes.default.number,
    valueFormatter: _propTypes.default.func
  }))
} : void 0;