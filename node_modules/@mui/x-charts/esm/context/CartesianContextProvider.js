import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { scaleBand, scalePoint } from 'd3-scale';
import PropTypes from 'prop-types';
import { getExtremumX as getBarExtremumX, getExtremumY as getBarExtremumY } from '../BarChart/extremums';
import { getExtremumX as getScatterExtremumX, getExtremumY as getScatterExtremumY } from '../ScatterChart/extremums';
import { getExtremumX as getLineExtremumX, getExtremumY as getLineExtremumY } from '../LineChart/extremums';
import { getScale } from '../hooks/useScale';
import { DrawingContext } from './DrawingProvider';
import { SeriesContext } from './SeriesContextProvider';
import { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';
import { getTicksNumber } from '../hooks/useTicks';
import { jsx as _jsx } from "react/jsx-runtime";
// TODO: those might be better placed in a distinct file
const xExtremumGetters = {
  bar: getBarExtremumX,
  scatter: getScatterExtremumX,
  line: getLineExtremumX
};
const yExtremumGetters = {
  bar: getBarExtremumY,
  scatter: getScatterExtremumY,
  line: getLineExtremumY
};
export const CartesianContext = /*#__PURE__*/React.createContext({
  xAxis: {},
  yAxis: {},
  xAxisIds: [],
  yAxisIds: []
});
function CartesianContextProvider({
  xAxis,
  yAxis,
  children
}) {
  const formattedSeries = React.useContext(SeriesContext);
  const drawingArea = React.useContext(DrawingContext);
  const value = React.useMemo(() => {
    var _xAxis$map, _yAxis$map;
    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {
      var _ref, _formattedSeries$char;
      const getter = getters[chartType];
      const series = (_ref = (_formattedSeries$char = formattedSeries[chartType]) == null ? void 0 : _formattedSeries$char.series) != null ? _ref : {};
      const [minChartTypeData, maxChartTypeData] = getter({
        series,
        axis,
        isDefaultAxis
      });
      const [minData, maxData] = acc;
      if (minData === null || maxData === null) {
        return [minChartTypeData, maxChartTypeData];
      }
      if (minChartTypeData === null || maxChartTypeData === null) {
        return [minData, maxData];
      }
      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
    };
    const getAxisExtremum = (axis, getters, isDefaultAxis) => {
      const charTypes = Object.keys(getters);
      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);
    };
    const allXAxis = [...((_xAxis$map = xAxis == null ? void 0 : xAxis.map((axis, index) => _extends({
      id: `deaultized-x-axis-${index}`
    }, axis))) != null ? _xAxis$map : []),
    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY
    ...(xAxis === undefined || xAxis.findIndex(({
      id
    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{
      id: DEFAULT_X_AXIS_KEY,
      scaleType: 'linear'
    }] : [])];
    const completedXAxis = {};
    allXAxis.forEach((axis, axisIndex) => {
      var _axis$scaleType, _axis$min, _axis$max, _axis$min2, _axis$max2;
      const isDefaultAxis = axisIndex === 0;
      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);
      const scaleType = (_axis$scaleType = axis.scaleType) != null ? _axis$scaleType : 'linear';
      const range = [drawingArea.left, drawingArea.left + drawingArea.width];
      if (scaleType === 'band') {
        completedXAxis[axis.id] = _extends({}, axis, {
          scaleType,
          scale: scaleBand(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      if (scaleType === 'point') {
        completedXAxis[axis.id] = _extends({}, axis, {
          scaleType,
          scale: scalePoint(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      const extremums = [(_axis$min = axis.min) != null ? _axis$min : minData, (_axis$max = axis.max) != null ? _axis$max : maxData];
      const ticksNumber = getTicksNumber(_extends({}, axis, {
        range
      }));
      const niceScale = getScale(scaleType, extremums, range).nice(ticksNumber);
      const niceDomain = niceScale.domain();
      const domain = [(_axis$min2 = axis.min) != null ? _axis$min2 : niceDomain[0], (_axis$max2 = axis.max) != null ? _axis$max2 : niceDomain[1]];
      completedXAxis[axis.id] = _extends({}, axis, {
        scaleType,
        scale: niceScale.domain(domain),
        ticksNumber
      });
    });
    const allYAxis = [...((_yAxis$map = yAxis == null ? void 0 : yAxis.map((axis, index) => _extends({
      id: `deaultized-y-axis-${index}`
    }, axis))) != null ? _yAxis$map : []), ...(yAxis === undefined || yAxis.findIndex(({
      id
    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{
      id: DEFAULT_Y_AXIS_KEY,
      scaleType: 'linear'
    }] : [])];
    const completedYAxis = {};
    allYAxis.forEach((axis, axisIndex) => {
      var _axis$scaleType2, _axis$min3, _axis$max3, _axis$min4, _axis$max4;
      const isDefaultAxis = axisIndex === 0;
      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);
      const range = [drawingArea.top + drawingArea.height, drawingArea.top];
      const scaleType = (_axis$scaleType2 = axis.scaleType) != null ? _axis$scaleType2 : 'linear';
      if (scaleType === 'band') {
        completedYAxis[axis.id] = _extends({}, axis, {
          scaleType,
          scale: scaleBand(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      if (scaleType === 'point') {
        completedYAxis[axis.id] = _extends({}, axis, {
          scaleType,
          scale: scalePoint(axis.data, range),
          ticksNumber: axis.data.length
        });
        return;
      }
      const extremums = [(_axis$min3 = axis.min) != null ? _axis$min3 : minData, (_axis$max3 = axis.max) != null ? _axis$max3 : maxData];
      const ticksNumber = getTicksNumber(_extends({}, axis, {
        range
      }));
      const niceScale = getScale(scaleType, extremums, range).nice(ticksNumber);
      const niceDomain = niceScale.domain();
      const domain = [(_axis$min4 = axis.min) != null ? _axis$min4 : niceDomain[0], (_axis$max4 = axis.max) != null ? _axis$max4 : niceDomain[1]];
      completedYAxis[axis.id] = _extends({}, axis, {
        scaleType,
        scale: niceScale.domain(domain),
        ticksNumber
      });
    });
    return {
      xAxis: completedXAxis,
      yAxis: completedYAxis,
      xAxisIds: allXAxis.map(({
        id
      }) => id),
      yAxisIds: allYAxis.map(({
        id
      }) => id)
    };
  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);

  // @ts-ignore
  return /*#__PURE__*/_jsx(CartesianContext.Provider, {
    value: value,
    children: children
  });
}
process.env.NODE_ENV !== "production" ? CartesianContextProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  children: PropTypes.node,
  xAxis: PropTypes.arrayOf(PropTypes.shape({
    axisId: PropTypes.string,
    classes: PropTypes.object,
    data: PropTypes.array,
    disableLine: PropTypes.bool,
    disableTicks: PropTypes.bool,
    fill: PropTypes.string,
    id: PropTypes.string,
    label: PropTypes.string,
    labelFontSize: PropTypes.number,
    max: PropTypes.number,
    maxTicks: PropTypes.number,
    min: PropTypes.number,
    minTicks: PropTypes.number,
    position: PropTypes.oneOf(['bottom', 'left', 'right', 'top']),
    scaleType: PropTypes.oneOf(['band', 'linear', 'log', 'point', 'pow', 'sqrt', 'time', 'utc']),
    stroke: PropTypes.string,
    tickFontSize: PropTypes.number,
    tickSize: PropTypes.number,
    tickSpacing: PropTypes.number,
    valueFormatter: PropTypes.func
  })),
  yAxis: PropTypes.arrayOf(PropTypes.shape({
    axisId: PropTypes.string,
    classes: PropTypes.object,
    data: PropTypes.array,
    disableLine: PropTypes.bool,
    disableTicks: PropTypes.bool,
    fill: PropTypes.string,
    id: PropTypes.string,
    label: PropTypes.string,
    labelFontSize: PropTypes.number,
    max: PropTypes.number,
    maxTicks: PropTypes.number,
    min: PropTypes.number,
    minTicks: PropTypes.number,
    position: PropTypes.oneOf(['bottom', 'left', 'right', 'top']),
    scaleType: PropTypes.oneOf(['band', 'linear', 'log', 'point', 'pow', 'sqrt', 'time', 'utc']),
    stroke: PropTypes.string,
    tickFontSize: PropTypes.number,
    tickSize: PropTypes.number,
    tickSpacing: PropTypes.number,
    valueFormatter: PropTypes.func
  }))
} : void 0;
export { CartesianContextProvider };