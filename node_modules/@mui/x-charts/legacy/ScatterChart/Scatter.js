import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import * as React from 'react';
import PropTypes from 'prop-types';
import { getValueToPositionMapper } from '../hooks/useScale';
import { getIsFaded, getIsHighlighted, useInteractionItemProps } from '../hooks/useInteractionItemProps';
import { InteractionContext } from '../context/InteractionProvider';
import { jsx as _jsx } from "react/jsx-runtime";
function Scatter(props) {
  var series = props.series,
    xScale = props.xScale,
    yScale = props.yScale,
    color = props.color,
    markerSize = props.markerSize;
  var _React$useContext = React.useContext(InteractionContext),
    item = _React$useContext.item;
  var getXPosition = getValueToPositionMapper(xScale);
  var getYPosition = getValueToPositionMapper(yScale);
  var getInteractionItemProps = useInteractionItemProps(series.highlightScope);
  var xRange = xScale.range();
  var yRange = yScale.range();
  var isInRange = function isInRange(_ref) {
    var x = _ref.x,
      y = _ref.y;
    if (x < Math.min.apply(Math, _toConsumableArray(xRange)) || x > Math.max.apply(Math, _toConsumableArray(xRange))) {
      return false;
    }
    if (y < Math.min.apply(Math, _toConsumableArray(yRange)) || y > Math.max.apply(Math, _toConsumableArray(yRange))) {
      return false;
    }
    return true;
  };
  return /*#__PURE__*/_jsx("g", {
    children: series.data.map(function (_ref2, index) {
      var x = _ref2.x,
        y = _ref2.y,
        id = _ref2.id;
      return {
        x: getXPosition(x),
        y: getYPosition(y),
        id: id,
        dataIndex: index
      };
    }).filter(isInRange).map(function (_ref3) {
      var x = _ref3.x,
        y = _ref3.y,
        id = _ref3.id,
        dataIndex = _ref3.dataIndex;
      var isHighlighted = getIsHighlighted(item, {
        type: 'scatter',
        seriesId: series.id,
        dataIndex: dataIndex
      }, series.highlightScope);
      var isFaded = !isHighlighted && getIsFaded(item, {
        type: 'scatter',
        seriesId: series.id,
        dataIndex: dataIndex
      }, series.highlightScope);
      return /*#__PURE__*/_jsx("circle", _extends({
        cx: 0,
        cy: 0,
        r: markerSize,
        transform: "translate(".concat(x, ", ").concat(y, ")"),
        fill: color,
        opacity: isFaded && 0.3 || 1
      }, getInteractionItemProps({
        type: 'scatter',
        seriesId: series.id,
        dataIndex: dataIndex
      })), id);
    })
  });
}
process.env.NODE_ENV !== "production" ? Scatter.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  color: PropTypes.string.isRequired,
  markerSize: PropTypes.number.isRequired,
  series: PropTypes.shape({
    color: PropTypes.string,
    data: PropTypes.arrayOf(PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
      x: PropTypes.number.isRequired,
      y: PropTypes.number.isRequired
    })).isRequired,
    highlightScope: PropTypes.shape({
      faded: PropTypes.oneOf(['global', 'none', 'series']),
      highlighted: PropTypes.oneOf(['item', 'none', 'series'])
    }),
    id: PropTypes.string.isRequired,
    label: PropTypes.string,
    markerSize: PropTypes.number,
    type: PropTypes.oneOf(['scatter']).isRequired,
    valueFormatter: PropTypes.func.isRequired,
    xAxisKey: PropTypes.string,
    yAxisKey: PropTypes.string
  }).isRequired,
  xScale: PropTypes.func.isRequired,
  yScale: PropTypes.func.isRequired
} : void 0;
export { Scatter };