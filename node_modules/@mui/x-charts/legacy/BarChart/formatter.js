import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { stack as d3Stack } from 'd3-shape';
import { getStackingGroups } from '../internals/stackSeries';
import defaultizeValueFormatter from '../internals/defaultizeValueFormatter';
var formatter = function formatter(params) {
  var seriesOrder = params.seriesOrder,
    series = params.series;
  var stackingGroups = getStackingGroups(params);

  // Create a data set with format adapted to d3
  var d3Dataset = [];
  seriesOrder.forEach(function (id) {
    series[id].data.forEach(function (value, index) {
      if (d3Dataset.length <= index) {
        d3Dataset.push(_defineProperty({}, id, value));
      } else {
        d3Dataset[index][id] = value;
      }
    });
  });
  var completedSeries = {};
  stackingGroups.forEach(function (stackingGroup) {
    var ids = stackingGroup.ids,
      stackingOffset = stackingGroup.stackingOffset,
      stackingOrder = stackingGroup.stackingOrder;
    // Get stacked values, and derive the domain
    var stackedSeries = d3Stack().keys(ids).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach(function (id, index) {
      completedSeries[id] = _extends({}, series[id], {
        stackedData: stackedSeries[index].map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            a = _ref2[0],
            b = _ref2[1];
          return [a, b];
        })
      });
    });
  });
  return {
    seriesOrder: seriesOrder,
    stackingGroups: stackingGroups,
    series: defaultizeValueFormatter(completedSeries, function (v) {
      return v.toLocaleString();
    })
  };
};
export default formatter;